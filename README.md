# 무기팔아 먹고삽니다: 살래말래?
<img width="1920" height="1080" alt="Google_MainCover" src="https://github.com/user-attachments/assets/0d61beaa-d748-46f0-9a05-635cb155e16e" />


### 인게임 화면
| ![타이틀](https://github.com/user-attachments/assets/c4c94608-be1b-403a-b6bd-bec628ed87a0) | ![대장간](https://github.com/user-attachments/assets/6d0487b9-155b-4c27-aef5-e9379d1c5f07) | ![광산](https://github.com/user-attachments/assets/ad44d8ff-4811-44ff-9fc0-93605ec491d1) | ![레시피해금](https://github.com/user-attachments/assets/da30155f-1eea-4418-9ad7-92a14cac6a08) | ![무기강화](https://github.com/user-attachments/assets/a84a88c8-a6b6-40da-aa23-b66bdb72996d) |
|:---:|:---:|:---:|:---:|:---:|
| **타이틀 화면** | **대장간 자동 제작 및 판매 화면** | **광산 제자 배치 후 자동 채굴 화면** | **레시피 해금 화면** | **무기 강화 화면** |

## 🎮  프로젝트 개요

### 『무기 팔아먹고 삽니다』는 2D 경영 시뮬레이션 게임으로, 플레이어는 대장간 주인이 되어 최고의 대장간으로 성장시키자.

- 제자를 고용하고 적절히 배치하여 무기를 제작하고, 손님에게 판매하며, 광산에서 재료를 수급하고 대장간을 업그레이드할 수 있습니다.
- 무기 제작뿐만 아니라 강화, 보석 부여를 통해 강력한 장비를 완성하고, 직접 던전에 도전하여 대장간의 명성을 높일 수 있습니다.
- 플레이어의 전략과 선택에 따라, 효율적이고 효과적인 경영 방식으로 대장간을 최고의 위치로 성장시켜보시기 바랍니다.

---

## 📜 게임 가이드라인

### 광산 → 대장간 → 던전의 순환 구조

- **광산**
    - 재료를 채굴하는 장소입니다. 광석, 보석 원석 등 무기 제작과 업그레이드에 필요한 핵심 자원을 확보할 수 있습니다.
    - 광산에는 제자를 배치하여 핵심자원 획득이 가능하며, 각각의 제자를 클릭하여 채굴 부스트 버프를 부여 할 수 있습니다.
    - 다이아를 사용하여 현재 배치한 어시스턴트들의 능력에 비례하여 3시간 보상을 받을 수 있습니다.
    - 골드를 사용하여 상위 자원을 채굴 할 수 있는 광산을 해금할 수 있습니다.
- **대장간**
    - 확보한 재료로 무기를 제작합니다. 제작된 무기는 판매하여 자금을 확보하거나, 강화 및 보석 부여로 성능을 높일 수 있습니다.
- **던전**
    - 완성된 무기를 사용하여 도전할 수 있는 전투 콘텐츠입니다. 던전을 클리어하면 자원과 경험치 보상을 얻을 수 있으며, 다시 광산과 대장간으로 순환됩니다.
    - 던전에서 얻은 경험치는 대장간에서 제작 가능한 아이템의 레시피를 해금하는데 사용되며, 일반적으로 판매로 얻는 경험치보다 대량의 경험치를 얻을 수 있습니다.

---

## 🎰 세부 콘텐츠 소개

- **미니게임**
    - 광산 미니게임을 통해 하루에 제한적인 도전 횟수로 자원을 쉽게 취득이 가능합니다.
    - 미니게임 콘텐츠를 활용하여 저레벨 구간에서 고레벨 보석 및 리소스를 획득 할 수 있습니다.
- **제자 고용 & 해고 시스템**
    - 제자 가챠 기능으로 고용가능한 제자리스트를 확보하여 계약금을 지불하고 일정 시간이 지나면 지급하는 시급을 효율적으로 관리하고 배치할 수 있습니다.
    - 계약금이 부족하여 제자를 고용하지 못할 경우에는 보류 시스템을 이용하여 자금을 확보 한 이후 고용 할 수 있습니다.
    - 시급을 지급하지 못해 제자가 파업을 할 수 있습니다. 파업시 다시 자금을 확보하여 일정금액을 지불하면 재고용이 가능합니다.
    - 더 높은 등급의 제자를 확보하여 기존에 있는 제자를 해고하여 자금을 보다 효율적으로 활용 할 수 있습니다.
- **레시피 해금**
    - 손님을 받아 명성치가 올라가면 포인트를 얻어 원하는 아이템의 레시피를 해금할 수 있습니다.
    - 무기별 제작 시간, 판매 금액, 공격력 등의 차이가 있어 자신이 원하는 방향성을 가지고 대장간을 운영 할 수 있습니다.
- **대장간 강화**
    - 아이템을 판매하여 얻은 골드로 대장간을 강화 할 수 있습니다.
    - 판매가격을 늘리거나, 대장간을 보다 멋있게 꾸미기 위한 인테리어 등을 강화 할 수 있습니다.
    - 모든 대장간강화를 마치게 되면 기존의 대장간이 아닌 다른 대장간을 오픈 할 수 있습니다.
        - 무기 - 방어구 - 마법 대장간 순으로 해금이 진행됩니다.
- **아이템제작**
    - 레시피를 해금하여 아이템를 제작하게 되면 자동판매 할 수 있는 아이템의 종류가 늘어납니다.
    - 아이템 제작은 판매를 하기 위한 아이템이 아닌 직접 장착하여 던전에서 몬스터를 잡을 수 있는 무기로써 사용됩니다.
- **무기강화 & 보석부여**
    - 무기 강화
        - 골드를 사용해 아이템을 강화하여 능력치를 증가 시킬 수 있습니다.
        - 아이템의 등급별 강화최대 수치가 다르며, 1, 3, 5, 7번의 강화를 자동으로 강화 할 수 있는 자동강화 기능이 있습니다.
        - 다이아를 소모하여 강화 성공확율을 증가시켜 강화를 진행할 수 있습니다.
    - 보석부여
        - 4가지 종류의 보석을 통해 각 보석의 효과를 무기에 적용 시킬 수 있습니다.
        - 무기의 특성 및 던전의 특성에 맞춰 무기에 보석을 부여하여 보다 원활히 던전 탐험이 가능합니다.
- **스킬**
    - 대장간 운영에 도움되는 스킬들을 가챠형태로 획득이 가능합니다.
    - 각 스킬들은 일정 개수 이상 보유하게 되면 스킬이 강화됩니다.
- **손님**
    - **단골손님**
        - 일정 확률로 손님 중 단골 손님이 등장합니다.
        - 클릭시 단골손님은 기분이 좋아지며 컬렉션 북에 등록됩니다.
        - 단골손님을 일정 횟수 이상 상호작용하게 되면 특별한 보상을 얻을 수 있습니다.
    - **진상손님**
        - 일정 확률로 손님 중 진상손님이 등장합니다.
        - 클릭하지 못하면 진상손님은 플레이어의 골드를 훔쳐갑니다.
        - 클릭시 단골손님을 내쫒으며 골드를 지킬 수 있습니다.
        

---

## 기술적인 도전 과제

### 💡 담당자 : 이수명
<details>
<summary><h4>광산 조수(FSM) 이동·작업 루프 안정화</h4></summary>

**⚠️ 문제 사항**

- 타일맵 지형에서 조수가 **오브젝트에 끼이거나 소각 회전**(제자리 턴)하는 현상 발생.
- 이동/작업/대기 상태 변화가 애니메이터와 **비동기적으로 동작**하여, 작업은 멈췄는데 채광 모션은 계속되는 등 **연출-로직 불일치**.
- 버프(채광 속도/성공률)와 쿨다운이 **UI 스택**에서 따로 갱신되어 **남은 시간 표기**와 실제 효과 시간에 차이가 발생.
- 동일 슬롯 교대 배치 시, 이전 조수의 FSM이 **슬롯 참조를 해제하지 못하고** 업데이트를 계속 수행(메모리/CPU 낭비).

**🆕 개선 방식**

- **경량 FSM(Idle/Walk/Work) 도입**: 상태 전환 순간에 애니메이터를 직접 동기 호출하도록 규약화(상태↔연출 원자화).
- **타일맵 장애물 샘플링 검사**: 목적지까지 **균등 구간 보간**으로 충돌 후보 타일을 샘플링해, 충돌 예상 시 대체 경로/재시도(최대 N회)로 탈출.
- **버프/쿨다운 HUD를 FSM 루프 내로 통합**: 남은 시간 텍스트 노출/종료 콜백을 FSM이 직접 제어하여 **시간-효과-연출** 3자 동기화.
- **슬롯–FSM 매핑 테이블** 도입: 슬롯 교대 시 “등록 해제 → 신규 등록” 순서 강제, 해제 실패 감지 시 강제 종료/정리 루틴 실행.

**✅ 개선 결과**

- 끼임/제자리 회전 **재현 빈도 급감**, QA 장시간 러닝에서 **작업 정체 이슈 미발생**.
- 작업/연출/버프 시간이 **완전히 일치**하여, 사용자 체감 이질감 해소.
- 슬롯 교대/제거 시 **유령 FSM**(dangling update) 제거, 프레임 타임 흔들림 완화.
- 로그 기준 장애물 탈출 재시도 횟수 상한 내에서 안정 동작, **소프트락 케이스 제거**.
</details>
<details>
<summary><h4>광산 잠금/해제 경제 UI 일괄 갱신 & 어드레서블 스폰 파이프라인</h4></summary>

**⚠️ 문제 사항**

- 광산 그룹별 **해금 비용/가능 여부**가 여러 UI에서 중복 계산되어 **표시 불일치**가 발생.
- 프리팹 로드가 Resources 의존일 때 **로딩 스파이크/메모리 상주**가 발생하고, 동시 스폰에서 **중복 생성** 사례가 보고됨.
- 정보 팝업이 중복 생성되어 **입력 차단/닫기 순서 꼬임**.

**🆕 개선 방식**

- **일괄 갱신 엔트리(RefreshAll)**: 플레이어 골드/해금 플래그를 **한 번 계산**하여 그룹 단위 `ShowBlock(잠금, 비용, 가용 여부)` 호출 → **표시 책임을 그룹 뷰로 위임**.
- **Addressables 비동기 스폰 표준화**: 로드 완료 시점에만 스폰/부모·정렬·레이어를 세팅하고, 실패/취소 시 **안전 폴백**. 슬롯–스폰 오브젝트–FSM을 **사전(Dict)** 으로 단일 소유권 관리.
- **팝업 단일 인스턴스 보장**: 팝업 참조를 보관하여 열기 요청 시 **이미 열려 있으면 무시**, 닫힘 콜백에서 참조 해제.

**✅ 개선 결과**

- 경제 상태 변경(골드 획득/소모, 해금) 후 UI **즉시 일관 반영**, 표시 불일치 제거.
- 비동기 스폰에서 **중복 생성/부모 누락** 이슈 종결, 메모리 스파이크 완화.
- 정보 팝업 **중복 오픈 방지**로 입력 막힘/닫힘 꼬임 해소, 사용자 흐름 매끄러움 개선.
</details>
<details>
<summary><h4>정련/세공: 최대 제작량 계산 정확도 & 재료 검증 신뢰도 향상</h4></summary>

**⚠️ 문제 사항**

- 슬라이더/“최대 제작” 버튼 사용 시, **정수 나눗셈 반올림**과 재고 동시 변동(다른 UI/시스템)이 겹치면 **한 단위 과다/과소 소모**.
- 재료 키/대체 재료(주괴↔원광) 혼재로 **HasEnough** 검증이 UI와 실제 차감 로직에서 **다르게 해석**되는 케이스.

**🆕 개선 방식**

- **단일 소스 계산기**: 선택한 산출물의 `RequireAmount × 수량`을 **인벤토리 질의(스냅샷)** 기반으로 산출하고, 슬라이더/버튼/입력 모두 이 계산기를 호출.
- **대체 재료 매핑표**(원광→주괴)를 데이터 레이어에서 먼저 해석하여, **UI/검증/차감**이 같은 키셋으로 동작하도록 통일.
- **원자적 차감**: `UseCraftingMaterials`가 성공하면 **한 번에** 차감, 실패 시 **전부 롤백**, UI는 **결과 이벤트**에만 반응.

**✅ 개선 결과**

- “최대 제작” 정확도 확립, **한 단위 오차/이중 차감** 불만 제거.
- 원광/주괴 혼재 상황에서도 **검증-차감-표시가 일관**.
- 다중 UI가 동시에 열려 있어도 **경쟁 조건 없이** 신뢰 가능.
</details>
<details>
<summary><h4>강화/정련 결과 팝업–인벤토리–세이브 트랜잭션화</h4></summary>

**⚠️ 문제 사항**

- 결과 팝업을 먼저 띄우고 저장이 뒤따를 때, 앱 종료/크래시 시 **상태 불일치**(팝업은 성공, 데이터는 미반영).
- 다중 창(제작/정련/강화) 동시 열림에서 **이벤트 경쟁**으로 UI가 서로 덮어쓰는 현상.

**🆕 개선 방식**

- **트랜잭션 시퀀스**: (1) 전제 검증 → (2) 자원/보호재 소모 → (3) 결과 적용(아이템 부여/변경) → (4) 세이브 커밋 → (5) UI 이벤트 브로드캐스트 → (6) 결과 팝업.
- **전역 이벤트 큐**로 결과 브로드캐스트를 **순차 처리**하고, 창별로 **자기 타입 이벤트만 수신**하도록 필터.
- 실패 시 **원복 경로**를 표준화(차감/적용 역순 복원).

**✅ 개선 결과**

- 비정상 종료/네트워크 단절 상황에서도 **데이터 일관성 보장**(팝업=실제 상태).
- 동시창 사용 시 **표시 충돌 제거**, UI 이벤트가 **예측 가능한 순서**로 처리.
</details>

---

### 💡 담당자 : 박경택
<details>
<summary><h4>손님 시스템 구현</h4></summary>

- 손님 이동 구현 방식
  - **이동시스템**
    경영 시뮬레이션에서 대장간을 방문하는 손님들을 `NavMesh` 대신 웨이포인트+슬롯 예약으로 고객 이동을 설계해 CPU/메모리 사용을 최소화
    0번째 인덱스(자신의 차례)까지 대기후 물건 구매 후 퇴장 포인트로 이동
  - **상태 머신, 이벤트**
    **`FSM 패턴`** 을 사용하여 입장/큐까지도달/구매지점으로이동/상호작용/퇴장 으로 이동
  - **대기열/슬롯**
    `QueueSlot`과 점유 플래그를 입장 시 대기 슬롯을 배정함 `O(1)` 에 가깝게 손님을 배치 및 반납함 동시에 손님이 와도 안정적으로 동작함
    중간에 손님이 구매후 퇴장하거나 화를내며 이탈할경우 뒤 손님을 한칸씩 당기며 자연스러운 줄 이동 연출
  - **오브젝트 풀링**
    손님이 퇴장하면 파괴하는것이 아닌 `PoolManager`(관리자)를 통해 다시 입장할때까지 Active(false)

- **⚠️ NaviMesh를 사용하지 않는 근거**
  - 손님이 자주 방문하며 더 많은 손님이 방문했을 경우 메모리 사용량이 증가 할꺼라고 생각함.
  - 고정된 루트를 이동하기 때문에 사용하지 않음
  - 동선 연출이 쉽기 때문에 사용하지 않음
</details>
<details>
<summary><h4>미니게임 구현 (광석 발굴 게임)</h4></summary>

- 땅굴을 판다는 컨셉으로 보석을 획득하는 간단한 미니게임 구현
- **배치 방식(좌표 계산)**
  - `width` * `height` 크기를 기준으로 광석을 배치
  - 2차원 그리드 행렬을 구성하여 x,y 인덱스로 좌표를 관리
  - `TreasureData(SO오브젝트)`에서 이미지를 해당 모양으로 자른 후 사용함
- **겹침 방지**
  - 보물은 `SO(Scriptable Object)`로 모양을 가지고 무작위 앵커를 선택한 뒤
  - 각 오프셋 칸이 보드 내부이며 비어있을 경우에만 배치하였음
  - 조건 불충족시 다른 앵커로 재시도 하여 서로 겹치지 않게 조정하였음
- **결과 처리**
  - 보석을 찾을때 마다 결과창에 `RewardImage`을 넣어줌
</details>
<details>
<summary><h4>시간 통합 및 일일 퀘스트</h4></summary>

- `TimeManager`를 통하여 UTC 시간 연동하여 클라이언트 시간을 사용하지 않고 외부 시간 사용
- `InitializeTime` 을 사용하여 비동기 서버 시간을 동기화 시켜 메인스레드를 정지 없이 작동시켜 게임 흐름에 방해를 주지 않음
- 네트워크 계층은 `UnityWebRequest`를 사용
- 자정을 기준으로 `DailyQuestManager` 에서 일일 퀘스트를 리셋
  - `RandomPick` 메서드를 통하여 자정에 퀘스트 최신화 퀘스트 중복을 피하기 위해 `Dictionary`사용
  - `Json` 으로 저장하여 현재 퀘스트 진행도 및 상황을 저장하여 재접속을 해도 데이터 유지

- **⭐ UTC를 연결하게 된 이유**
  - 런타임이 아닐때 시간이 흐르지 않았음
  - 시간이 필요한 기능들 통일시킬 필요가 있었음
  - 내부에서 시간을 의도적으로 변경할 가능성이 있었음
</details>

---

### 💡 담당자 : 이희민
<details>
<summary><h4>제자 시스템 구현</h4></summary>

- 제자 정보 구현
  - JSON 파일에 제자를 하나씩 고유하게 설정해줘서 등급과 능력치를 나눠서 각자 제자마다 특색있게 데이터를 구축

- 영입 시스템
  - JSON 파일에 각각 제자들의 데이터를 담아두고 플레이어가 보유하지 않은
  - 제자들을 영입 목록에서 등급마다 확률을 지정해두고 뽑는 방식
  - 제자 데이터에 담긴 최소 , 최대 고용비를 불러와서 그 내부에 랜덤으로 값을 부여해주는 식으로 골드 소모량 설정
  - 만일 제자를 보류할 경우, 이 데이터를 저장해서 게임을 껐다가 키더라도
  - 유지되는 방식으로 설정

- 시급 시스템
  - 제자마다 각자 최소 , 최대 시급을 JSON 파일에 지정해두고, 영입할 때
  - 최소와 최대를 벗어나지 않게 그 안에서 값을 랜덤으로 굴려서 시급이 지정되게
  - 설정 후, 제자를 영입하면 1분마다 모든 제자의 시급을 합산하여 플레이어 골드
  - 차감하는 시스템으로 설정

- 탈주 시스템
  - 시급을 지급하지 못할 경우, 인벤토리에 존재하지만 사용할 수 없으며
  - 재영입을 통해서 다시 사용할 수 있게 시스템을 구축
</details>
<details>
<summary><h4>제자 시스템으로 골드 소모량 조절</h4></summary>

- 영입 골드
  - 제자 데이터에 담긴 최소 , 최대 고용비를 불러와서 그 내부에 랜덤으로 값을 부여해주는 식으로 골드 소모량 설정

- 시급 골드
  - 영입 골드보단 소량이지만, 등급이 높을 수록 비싼 급여 만큼의 골드를
  - 1분마다 유저의 골드를 소모시키는 형식으로 지속적으로 소모할 수 있도록 설정

- 재영입 골드
  - 영입보다 더 비싸게 값을 책정하여 유저가 제자를 영입할 때, 제자의 시급을 전부
  - 내줄 수 있는 수준에서 영입할 수 있도록 밸런스 조절 및 이를 실패할 경우 큰 금액의 골드를 소모시키도록 설정
</details>

---

### 💡 담당자 : 장민제
<details>
<summary><h4>다중 대장간(ForgeType) 관리 구조 설계</h4></summary>

**⚠️ 문제 사항**

- 초기 구조에서는 하나의 대장간만 존재해 기능 확장이 어려웠음.
- 무기/방어구/마법 대장간을 따로 관리하려고 하니, 공통 기능과 전용 기능을 어떻게 분리·관리할지가 불명확함.
- 각 대장간별 업그레이드, 잠금 해제, 버프 적용 로직이 중복될 가능성이 높았음.

**🆕 개선 방식**

- **ForgeManager와 Forge 클래스 분리**
  - **ForgeManager** → 전체 대장간 공통 관리 (자원, 명성, 레시피 포인트, 스킬, 전체 저장/로드, 조수 장착 정보 등)
  - **Forge** → 개별 대장간 인스턴스 관리 (제작, 판매, 손님 스폰, 시각 효과, 업그레이드 상태, 맵 활성화 등)
- **저장/로드 데이터 구조 개선**
  - `ForgeCommonData` : 전체 대장간 공통 데이터 저장
  - `ForgeTypeData` : 개별 대장간 데이터 저장
  - 공통 데이터와 개별 데이터 로드를 명확히 분리해, 필요 시 특정 대장간만 개별 로드 가능
- **조수 장착 구조 개선**
  - `EquippedAssistant`를 `Dictionary<ForgeType, Dictionary<SpecializationType, AssistantInstance>>` 형태로 변경해 Forge별, 역할별 조수 상태를 직관적으로 관리 가능하게 함.
- **이벤트 기반 UI 갱신**
  - 자원/명성/레벨 변경 시 `ForgeEventHandler`로 이벤트를 호출해 UI와 게임 로직이 자동 동기화되도록 함.
- **Forge 내부 책임 최소화**
  - ForgeManager가 현재 활성 대장간을 설정 및 관리하고, Forge는 자기 자신과 직접 관련된 로직만 수행하도록 의존성 줄임.

**💫 개선 결과**

- **유지보수성 향상**
  - ForgeManager와 Forge의 책임이 명확히 분리되어, 각 클래스의 수정 범위와 영향 범위가 축소됨.
  - 새로운 ForgeType 추가 시 Forge 클래스만 수정하면 되고, 공통 로직은 ForgeManager를 통해 재사용 가능.
- **데이터 안정성 강화**
  - 저장/로드 시 데이터 구조가 명확해져, 특정 대장간 데이터만 따로 백업, 불러오기 가능.
  - 잘못된 데이터 로딩으로 전체 게임 상태가 망가질 위험 감소.
- **확장성 확보**
  - 새로운 ForgeType, 조수 유형, 제작/판매 시스템 추가 시 구조 변경 없이 확장 가능.
  - 이벤트 기반 UI 갱신으로, 자원/명성 변경 시 UI와 로직 간의 동기화 버그 최소화.
- **코드 가독성 및 테스트 용이성 증가**
  - ForgeManager와 Forge가 단일 책임 원칙에 더 가까워져, 단위 테스트나 기능별 디버깅이 쉬워짐.
</details>
<details>
<summary><h4>게임 진행상황 저장 시스템</h4></summary>

**⚠️ 문제 사항**

- **저장/로드 코드의 중복과 분산**
  - 각 기능(인벤토리, 조수, 던전, 대장간, 스킬 등)이 개별적으로 저장/로드 로직을 구현해, 코드 중복이 심함.
  - 저장 호출 시 각 매니저 스크립트를 직접 찾아 호출해야 해, 새로운 저장 대상이 생길 때마다 GameManager 등 중앙 코드 수정 필요.
- **확장성 부족**
  - 기존 구조에서는 새로운 저장 대상 추가 시 기존 저장 호출부를 전부 수정해야 함.
  - 삭제(Reset) 기능이 저장/로드와는 별도로 관리되어, 기능 일관성이 떨어짐.
- **의존성 결합 문제**
  - 각 SaveSystem이 직접 게임 매니저나 다른 매니저 객체에 의존하는 구조라, 유닛 테스트나 독립 실행이 어려움.
- **유지보수 어려움**
  - 저장 포맷이 시스템별로 흩어져 있어, 경로/파일명 변경이나 직렬화 방식 변경 시 전체 코드를 찾아 수정해야 함.

**🆕 개선 방식**

- **ISaveHandler 인터페이스 도입**
  - `Save()`, `Load()`, `Delete()` 세 메서드를 표준화해 모든 저장 대상이 동일한 형태로 동작하도록 통일.
- **GameSaveManager 중앙 관리**
  - `RegisterSaveHandler(ISaveHandler handler)`를 통해 각 시스템의 저장 핸들러를 등록.
  - `SaveAll()`, `LoadAll()`, `DeleteAll()` 메서드로 모든 저장 대상을 일괄 관리.
  - 새로운 저장 시스템 추가 시 `RegisterSaveHandler` 호출만 하면 전체 저장/로드/삭제 로직에 자동 포함.
- **개별 SaveSystem 분리**
  - 각 기능별 SaveSystem은 순수 데이터 직렬화/역직렬화와 파일 입출력만 담당.
  - 각 SaveHandler 클래스는 SaveSystem과 실제 게임 매니저(InventoryManager, AssistantManager 등)를 연결하는 어댑터 역할 수행.
- **데이터 경로 및 포맷 일관화**
  - 모든 SaveSystem에서 `Application.persistentDataPath` 기반 경로 사용.
  - JSON 직렬화를 통일하여 데이터 확인/디버깅 용이.

**💫 개선 결과**

- **확장성 대폭 향상**
  - 새로운 저장 대상(예: MineSaveSystem) 추가 시 기존 코드 수정 없이 `RegisterSaveHandler(new MineSaveHandler(...))` 한 줄로 통합 가능.
- **중복 제거 및 유지보수 용이**
  - 저장 호출 로직이 GameSaveManager로 단일화되어, 코드 중복이 제거되고 유지보수 범위 축소.
- **안정성 및 일관성 확보**
  - 모든 저장 대상이 동일한 인터페이스(ISaveHandler)를 사용하므로, 저장/로드/삭제 로직의 일관성 유지.
  - 기능별 SaveSystem이 독립적으로 동작 가능해, 특정 기능만 따로 저장/로드하거나 테스트 가능.
- **디버깅 및 QA 효율 증가**
  - JSON 기반 저장으로 실제 저장 내용을 쉽게 확인 가능.
  - 특정 SaveSystem만 선택적으로 로드/삭제 가능해 QA 과정에서 유연성 확보.
</details>
<details>
<summary><h4>대장간 스킬 시스템 구현</h4></summary>

**⚠️ 문제 사항**

- 기존 대장간 시스템에는 플레이어가 능동적으로 생산 효율을 높일 수 있는 **스킬 기능**이 없었음.
- 아이템 제작 속도, 성공 확률, 판매 가격 상승 등 다양한 효과를 일시적으로 적용하는 로직을 구현하려 했으나,
  기존 `Forge` 클래스 구조가 단일 수치 계산 방식이라 **버프 적용/해제 로직을 유연하게 넣기 어려움**.
- 각 스킬 효과의 지속 시간, 중첩 여부, 적용 대상(무기/방어구/마법 대장간 등)이 다르기 때문에
  **중복된 조건문과 하드코딩**이 많아질 위험이 있었음.

**🆕 개선 방식**

1. **스킬 데이터 구조화**
   - 각 스킬의 타입, 지속 시간, 효과 수치, 적용 대상 등을 담는 `SkillData` 구조 설계.
   - JSON/ScriptableObject 형태로 관리하여 스킬 추가·변경 시 코드 수정 없이 가능하게 함.
2. **ForgeManager에 스킬 관리 모듈 추가**
   - `ForgeManager`에 `ActiveSkills` 리스트를 두고, 스킬 발동 시 해당 리스트에 등록.
   - 각 스킬의 남은 지속 시간을 `Update`에서 체크하고, 시간이 끝나면 자동으로 해제.
3. **효과 적용 방식 개선**
   - Forge 계산 로직(예: `GetCraftTime`, `GetSalePrice`, `GetSuccessRate`)에서
   - 스킬 리스트를 순회하며 해당 스킬이 영향을 주는 경우 **곱연산/가산연산** 방식으로 최종 수치 계산.
   - 예: 제작 시간 단축 스킬 → `baseTime * CraftTimeMultiplier`.
4. **이벤트 기반 버프 처리**
   - 스킬 발동 시 `RaiseSkillCoolDownStarted` , RaiseSkillCooldownUpdate, RaiseSkillCooldownFinished,
   - UI에서 실시간으로 버프 아이콘, 남은 시간 표시 가능.

**💫 개선 결과**

- 스킬 추가 시 **코드 수정 없이 데이터만 등록**하면 게임에 바로 적용 가능.
- 제작 시간, 판매 가격, 성공 확률 등 다양한 버프를 **유연하게 조합** 가능.
- 유지보수 시 중복 코드와 조건문 분기를 최소화하여 **가독성과 확장성 향상**.
- 플레이어가 제작 전략을 세울 수 있어 게임 플레이의 **전략성·몰입도 증가**.
</details>

---

# 사용된 기술 스택

- **Visual Studio** - 2022
- **Unity - 2022.3.17f1**
- **GitHub**
- **Design**
    - Photoshop 2023
- **Collaboration**
    - GoogleSheet
    - Figma
    - Drawio
    

---
<details>
<summary><h1>클라이언트 구조</h1></summary>

## 전체 구조

<img width="2209" height="1026" alt="SRMR_흐름도 drawio" src="https://github.com/user-attachments/assets/8af4bdc0-b7a7-45be-8e1d-b65fdf914d2e" />

### 코어/인프라
| 클래스 | 주요 메서드 | 설명 | 주요 의존성 / 관련 컴포넌트 |
| :--- | :--- | :--- | :--- |
| **GameManager.cs** | `Awake`, `Start`, `OnApplicationQuit`, `DeleteSaveData` | 런타임 전역 허브. 주요 매니저를 초기화하고, 테스트 유틸리티를 제공하며, 앱 종료 시 세이브 커밋을 트리거합니다. | `DataManager`, `GameSaveManager`, `ForgeManager`, `InventoryManager`, `DailyQuestManager`, `SoundManager`, 각 UI `Window`들 |
| **SoundManager.cs** | `Play`, `PlayBGM`, `StopBGM`, `PlaySFX`, `ChangeBGMWithFade` | BGM/SFX 재생 및 페이드 전환을 담당하며, 씬/이벤트 단위 사운드를 일원화하고 볼륨/뮤트 상태를 관리합니다. | `LoadSceneManager` (씬 전환 BGM), UI/전투/제작/상호작용 |
| **TimeManager.cs** | `Awake`, `InitializeTime`, `Now`, `GetWorldTimeAPI` | 게임 내 시간 소스를 단일화하여 `UTC+오프셋` (KST)이 적용된 시간을 제공하고, 필요 시 외부 API로 서버 시간을 동기화합니다. | `DailyQuestManager` (일일 리셋), 시간 의존 UI/퀘스트 |
| **GameSaveManager.cs** | `RegisterSaveHandler`, `SaveAll`, `LoadAll`, `DeleteAll` | 세이브 브로드캐스터 역할을 하며, 등록된 `ISaveHandler`들에게 저장/로드/삭제를 전파하여 중앙에서 관리하고 트랜잭션성을 확보합니다. | `Inventory`/`Forge`/`Dungeon`/`Mine`/`Skill`/`Recruit` 등 각 서브시스템의 `ISaveHandler` |
| **DataManager.cs** | (생성자 레벨 구성) | 모든 게임 데이터 로더의 집중 DI 허브입니다. 각종 데이터를 JSON 파일에서 일괄 로드하여 각 시스템에 타입 안정적인 로더를 공급합니다. | `Resources/Data/*.json` 일괄 로딩 |

### 씬/카메라/UI프레임
| 클래스 | 주요 메서드 | 설명 | 주요 의존성 / 관련 컴포넌트 |
| :--- | :--- | :--- | :--- |
| **LoadSceneManager.cs** | `LoadSceneAsync`, `UnLoadScene`, `UnLoadSceneCoroutine`, `FadeRoutine`, `EnsureMainCameraActive`, `EnsureMainCameraReallyActive`, `SetMainCamera`, `GetBGMNameBySceneType` | Additive 로딩을 표준화하고, 로딩 캔버스 알파/차단 및 AnimationCurve 기반 페이드를 처리합니다. 씬 전환 시 BGM 교체 및 메인 카메라 활성화를 보정합니다. | `SceneCameraState`(활성 플래그), `SoundManager`, 메인/UI/광산 카메라 |
| **SceneCameraState.cs** | `(static flag) IsMineSceneActive` | 씬 레벨 카메라의 상태 플래그를 관리하며, 광산 진입/복귀 시 메인 카메라 토글 판단 기준으로 사용됩니다. | `LoadSceneManager`, `MineSceneManager` |
| **UIManager.cs** | `OpenUI<T>`, `CloseUI`, `(내부) LoadPrefab`, `GetParentByType` | Fixed/Window/Popup 3계층의 UI 루트를 관리합니다. 제네릭 `OpenUI<T>`로 타입-세이프 인스턴스를 획득하고 `Init`을 호출하며, 팝업/창 열림·닫힘 시 `BlockRay` 자동 토글 및 `UIEffect`와 연동됩니다. `activeUIs` Dict로 단일 인스턴스를 보장합니다. | 모든 `BaseUI` 파생 창들, `UIEffect`, `Resources` 프리팹 |
| **BaseUI.cs** | `Init`, `Open`, `Close` | 모든 UI의 공통 베이스 클래스입니다. `RootPanel` 자동 바인딩, `UIManager`·`GameManager` DI, 열림/닫힘 로직을 표준화합니다. | 상속: `CraftWeaponWindow`, `RefineSystemWindow`, `UpgradeWeaponWindow`, `DungeonWindow` 등 |
| **UIEffect.cs** | `PopupOpenEffect`, `PopupCloseEffect`, `TextScaleEffect` | DOTween 기반의 UI 공용 연출을 제공합니다. 팝업 열기/닫기 이징 및 콜백 보장, 텍스트 펌핑 등 연출 일관성을 유지합니다. | `UIManager`에서 자동 호출, 각 `Window`/`Popup` |

### 자원/아이템
| 클래스 | 주요 메서드 | 설명 | 주요 의존성 / 관련 컴포넌트 |
| :--- | :--- | :--- | :--- |
| **GameManager.cs** | `Awake`, `Start`, `OnApplicationQuit`, `DeleteSaveData` | 런타임 전역 허브. 주요 매니저(데이터/세이브/포지/인벤토리/던전/튜토리얼 등)를 초기화하고, 테스트 유틸 제공. 앱 종료 시 세이브 커밋 트리거. | `DataManager`, `GameSaveManager`, `ForgeManager`, `InventoryManager`, `DailyQuestManager`, `SoundManager`, 각 UI `Window`들 |
| **SoundManager.cs** | `Play`, `PlayBGM`, `StopBGM`, `PlaySFX`, `ChangeBGMWithFade` | BGM/SFX 재생·페이드 전환. 씬/이벤트 단위 사운드 일원화. 볼륨/뮤트 상태 관리. | `LoadSceneManager`(씬 전환 BGM), UI/전투/제작/상호작용 |
| **TimeManager.cs** | `Awake`, `InitializeTime`, `Now`, `GetWorldTimeAPI` | 시간 소스 단일화. UTC+오프셋(+9, KST) 적용된 Now() 제공. 필요 시 외부 API로 서버 시각 동기화(SSL 무시 핸들러 포함). | `DailyQuestManager`(일일 리셋), 시간 의존 UI/퀘스트 |
| **GameSaveManager.cs** | `RegisterSaveHandler`, `SaveAll`, `LoadAll`, `DeleteAll` | 세이브 브로드캐스터. 등록된 `ISaveHandler`들에게 전파 호출하여 저장/로드/삭제를 중앙화. 순서 경쟁을 줄이고 트랜잭션성 확보. | `Inventory`/`Forge`/`Dungeon`/`Mine`/`Skill`/`Recruit` 등 각 서브시스템의 `ISaveHandler` |
| **DataManager.cs** | (생성자 레벨 구성) | 모든 게임 데이터 로더의 집중 DI 허브. `ItemDataLoader`, `CraftingDataLoader`, `CraftingRecipeLoader`, `DungeonDataLoader`, `AssistantDataLoader`, `PersonalityDataLoader`, `SpecializationDataLoader`, `ForgeUpgradeDataLoader`, `SkillDataLoader`, `MineLoader`, `QuestLoader`, `CustomerDataLoader`, `RegularDataLoader`를 생성·보관. | `Resources/Data/*.json` 일괄 로딩, 각 시스템으로 타입 안정 로더 공급 |

### 광산(Mine)
| 클래스 | 주요 메서드 | 설명 | 주요 의존성 / 관련 컴포넌트 |
| :--- | :--- | :--- | :--- |
| **MineSceneManager.cs** | `SetActiveMine`, `OnCollectAllButton`, `ClearSlotAssistant`, `GetBuffMultiplierForSlot`, `SetMainUIClickable`, `SetMainCameraActive`, `SetUICameraActive`, `SetMineCameraActive`, `OnReturnToForgeMain`, `LoadFromSaveData`, `ResetUnlockedMines`, `ClearAllSlots`, `RemoveFiredAssistantsFromMine`, `RemoveEquippedAssistantsFromMineOnly`, `RemoveInactiveAssistantsFromMine`, `ShowMineInfoPopup` | 광산 그룹/슬롯/잠금·해금/카메라/UI 전반의 오케스트레이션. Additive 진입 시 카메라·오디오 토글, Addressables로 제자 프리팹 스폰(정렬/부모/슬롯-FSM 매핑), “모두 수령”, 광산 정보 팝업 단일 인스턴스 보장, 잠금블록 UI 일괄 갱신. | `SceneCameraState`, `InventoryManager`, `Addressables`, `MineAssistantFSM`, `MineResourceCollectManager`, `UIManager`, `ForgeManager` |
| **MineAssistantFSM.cs** | `Init`, `Update`, `SetState(Idle/Walk/Work)`, `SetRandomDestination`, `IsObstacleBetween`, `HandleBuffAndCooldown`, `UpdateCooldownText`, `StartBuff`, `EndBuff`, `LoadBuffState`, `UpdateAnimatorSpeed`, `(UI) CreateCooldownText`, `DestroyCooldownText` | 경량 FSM로 조수 이동/작업 루프 제어. 타일맵 보간 샘플링 기반 장애물 검사, 애니메이터 직접 재생으로 상태-연출 일치. 버프/쿨다운 타이머·텍스트를 FSM 내부에서 동기화. 슬롯 교체 시 버프 상태 로드. | `MineSceneManager`(그룹/타일맵 제공), `SoundManager`(발 소리/채광 음), FSM↔슬롯 매핑 Dict |
| **MineResourceCollectManager.cs** | `Awake`, `Update`, `SetCurrentMineGroupIndex`, `UpdateExpectedMiningAmount`, `CalculateMiningAmount`, `GetGradeMultiplier`, `GetMineSpecMultiplier`, `GetPersonalityMiningMultiplier`, `OnQuickCollectClicked`, `CollectAllResources`, `SetAmountRoot`, `ShowLackPopup` | 광산 채굴 예상량 계산/표시와 일괄 수령. 슬롯/등급/광산 스펙/성격 보정치 합성. 퀵 수령/일괄 수령에서 인벤토리에 원자적 지급. UI 루트 가시성 컨트롤. | `InventoryManager`(지급), `MineSceneManager`(그룹·슬롯), `Personality`/`Specialization` 로더 |

### 제자(Assistant)
| 클래스 | 주요 메서드 | 설명 | 주요 의존성 / 관련 컴포넌트 |
| :--- | :--- | :--- | :--- |
| **AssistantManager.cs** | `Init`, `RecruitSingle`, `RecruitMultiple`, `HandleSingleRecruit`, `SingleRecruitFlow`, `ConfirmTrainee`, `DismissAssistant`, `ClearAllAssistants`, `RemoveTrainee` | 제자 뽑기·확정·해고의 상위 조정자. 프리팹/버튼 스폰, 컨펌 이벤트 묶음, 연출 흐름을 관리합니다. | `AssistantFactory`, `RecruitPreviewManager`, `WageDataManager`, `GameSaveManager` |
| **AssistantFactory.cs** | `(생성·선택 로직)`, `CreateSmartRandomTrainee` 등 | 소유 키를 제외하고 등급 기본 가중치에 남은 수량을 곱하여 동적 가중치를 부여하는 뽑기 로직을 구현합니다. 특화 타입 필터 및 성격/전문화 조합을 부여합니다. | `AssistantDataLoader`, `PersonalityDataLoader`, `SpecializationDataLoader` |
| **RecruitPreviewManager.cs** | `Start`, `TryRecruitCandidateByType`, `StartRecruit`, `ApproveCandidate`, `RejectCandidate`, `HoldCandidate`, `HoldAllRemaining`, `AdvanceToNextCandidate`, `ShowSingleCandidateFromHeld`, `EndRecruitFlow`, `ReturnToProperUI`, `SetButtonsInteractable` | 5인 프리뷰 큐와 보류 큐 UX를 제어합니다. 보류 일괄 이동, 인덱스 가드 및 전이 가드로 연타/레이스 컨디션을 방지하며, 저장 즉시 반영, 보류 목록 복귀/삭제를 관리합니다. | `AssistantFactory`, `GameManager.HeldCandidates`, `GameSaveManager`, UI Popups |

</details>

---

<details>
<summary><h1>사용자 개선 사항</h1></summary>
  
### 유저 테스트 의견 종합 및 개선 방안 ( 8/5 ~ 8/8 )
  
| 이슈 | 개선 방안 |
| :--- | :--- |
| **튜토리얼 중 다른 버튼이 눌려 다음 진행이 막힘 (설정창 닫기 불가 포함)** | `TutorialManager`에 전역 클릭 차단 레이어(`CanvasGroup.blocksRaycasts`) 상시 적용, 단계 전환 시 `UIManager`로 허용 UI 화이트리스트만 열리도록 가드. 진행 지점 외 UI는 `OpenUI`를 intercept해 무시/큐잉. |
| **튜토리얼 안내가 눈에 잘 안 들어옴 (가독성/강조 부족)** | `TypeText` 타자 효과 유지하되, 키 문장 컬러 하이라이트·아이콘 삽입, `HighlightPos(xRatio, yRatio)` 세기를 높이고 배경 디머(알파↑) 적용. 맞춤법/어투 일괄 교정. |
| **튜토리얼 스킵 후 무엇을 해야 할지 모르겠음** | 스킵 시 핵심 가이드 팝업 묶음 자동 발송(광산/정련/강화/던전 첫 진입 시 1장 요약). `DailyQuestManager`와 연동해 “첫 퀘스트” 자동 부여로 다음 행동 유도. |
| **각 콘텐츠(던전/광산) 튜토리얼 부재** | 각 씬 첫 진입 시 `TutorialManager` 마이크로 튜토리얼 트리거(2~3 스텝): 진입→핵심 버튼→보상 수령. 진행 플래그 `PlayerPrefs` 또는 Save 핸들러로 유지. |
| **장비 제작소 글자 작고, 재료 구분 어려움** | `CraftWeaponWindow` 텍스트 동적 폰트 스케일(최소 가독 크기 보장), 아이템 아이콘 윤곽선/틀 색으로 재료 타입 구분. 부족 재료는 붉은 수치 + 툴팁. |
| **장착/해제 시 피드백 약함 (E표시만 확인)** | 장착 시 사운드 + 경미한 이펙트 + 슬롯 테두리 하이라이트. 해제 시 흐림 처리 및 진동(모바일 기준) 옵션. |
| **던전 2배속 희망** | `DungeonSystem`에 로컬 배틀 스피드 배수 도입(애니메이션/쿨타임/스폰 주기 동시 배율). 1×/2× 토글 UI 추가, 결과/보상 판정은 실시간 기준으로 보정. |
| **제작이 중단되어 진행 불가** | 제작 루프의 종속 이벤트(씬 전환/타임스케일/일시정지) 의존성 제거. 비가시 상태에서도 안전하게 갱신되도록 코루틴→업데이트 스케줄러 전환 검토. |
| **결과 팝업과 데이터 반영 순서 뒤섞임** | 모든 제작/정련/강화 결과를 세이브 커밋 후 팝업 노출하도록 통일. 실패 시 전부 원복. |
| **제작 재료/아이콘 가독성** | 색각 보정 팔레트, 툴팁에 텍스트 라벨 병기. 작은 글씨는 최소 크기 보장 규칙 도입. |
| **미니게임 완료해도 ‘마스터’ 퀘스트 미완** | MiniGame → `DailyQuestManager` 이벤트 연결 누락 점검. 성공 시 진행치 인크리먼트 발행, 실패/취소 분기 구분. |
| **던전 종료 시 보상 수령 없이 나가짐** | 보상 확정 → 저장 → UI 이벤트 → 팝업 순으로 트랜잭션 순서 고정. X 버튼 누르면 “보상 미수령 경고→수령 후 나가기” 유도. |
| **무기 쿨다운 순서 꼬임 (10→9 역전)** | 무기 슬롯을 우선순위 큐(다음 사용 가능 시각 기준)로 전환. 동일 time-stamp 충돌 시 슬롯 인덱스로 타이브레이크. |
| **단골 등록 모션 부재로 등록 여부 불명확** | 등록 전환 애니메이션(UI+캐릭터) 추가, 등록 성공 토스트/사운드. 단골 컬렉션 썸네일 플립 애니메이션으로 시각적 고정. |
| **진상 손님 상호작용 피드백 약함/돈 감소 혼란** | 연타 시 피격/떨림 모션·사운드 피드백, 성공/실패 규칙 툴팁. 실패 시 차감 근거 수치 노출. |
| **손님이 투명하게 보임 (자주 보고됨)** | `PoolManager` 반환 시 알파/소팅/레이어 초기화 루틴 추가. 스폰 직후 기본 `SpriteRenderer` 상태 강제(투명/비활성 잔재 제거). |
| **시급/고용 비용 정보 부족** | `WageDataManager` 연동, 등급/특화별 예상 월비용 미리보기/경고 배지 노출. 시급 부족 시 즉시 알림. |
| **10연(스킬/제자) 연출 느림, 스킵 원함** | 연출을 프레임 기반 경량으로 전환하고 “건너뛰기” 버튼 추가, 결과 요약 팝업 제공. |
| **채광 중 제자 빼내고 재배치가 안 됨** | `MineSceneManager` 슬롯–FSM 소유권 테이블 정비: 해제→소거→재배치 순 원자화. `Addressables` 스폰 실패 시 안전 복원. |
| **보호 재화 사용 여부 UI/로직 불일치 가능** | 보호 재화 플래그를 검증→차감→판정→결과까지 동일 경로로 통일. 실패 시 전액 롤백. |
| **강화 버튼이 성공/완료 후에도 눌림** | `UpgradeWeaponWindow` 버튼 상태를 계산기 결과 바인딩으로 전환(비용/보호재/성공률 단일 계산기). 강화 완료 콜백에서 명확히 비활성 후 재평가. |
| **“전부 정련/세공” 원클릭 필요** | Refine All 버튼 추가: 필요 총합 사전 검증→성공 시 일괄 처리→결과 팝업. 실패 시 가이드 CTA(광산/상점/대체 재료). |
| **보석 재료 적용 안 됨 (혼동/버그 보고)** | `RefineSystemWindow`의 입력 검증을 단일 재료 해석기로 통일(원광↔주괴 매핑). 인벤토리 질의 → 일괄 차감 → 일괄 지급 트랜잭션화. |
| **제작 속도 효율이 급격히 빨라짐** | `Forge` 스킬/시설 업/제자 버프의 합성 규칙을 가중-감쇠(soft cap)로 전환. 상한선·체감 완만화를 데이터 테이블화. |
| **던전 입장 전에 얻는 아이템 정보 필요** | 던전 슬롯에 주요 드랍/확률 대역 툴팁 추가, `DungeonWindow` 리스트에 미리보기 아이콘 노출. |
</details>

---

<details>
<summary><h1>코드 샘플 및 주석</h1></summary>

<details>
<summary><h4>1.  제자 리크루팅 허브</h4></summary>

*담당자 : 이희민*

- 제자 생성/스폰/미리보기/단·다중 뽑기 흐름을 통합하며, 다른 시스템(광산 배치/대장간 제자 배치)으로 이어지는 시발점 역할입니다.

### 예시 코드

```csharp
public void Init(GameManager gameManager)
{
    this.gameManager = gameManager;

    inventory = new AssistantInventory(gameManager.ForgeManager);
    factory = new AssistantFactory(gameManager.DataManager);
    spawner = new AssistantCardSpawner(
        largeTraineeCardPrefab,
        miniTraineeCardPrefab,
        singleDrawParent,
        multiDrawParent,
        factory,
        inventory
    );
    drawController = new RecruitDrawController(spawner, confirmRoot);
    canRecruit = true;
}
------------------------------------
public void RecruitSingle(SpecializationType? type = null)
{
    if (!canRecruit) return;
    canRecruit = false;

    HandleSingleRecruit(() => {
        var ownedKeys = inventory.GetAll().Select(a => a.Key).ToHashSet();
        return factory.CreateSmartRandomTrainee(ownedKeys, type);
    });
}
------------------------------------
public void RecruitMultiple(int count, SpecializationType? type = null)
{
    if (!canRecruit) return;
    canRecruit = false;
    drawController.StartMultipleRecruit(count, type);
}
```

- **Factory + Inventory + Spawner + DrawController**로 역할을 분리해 가독성과 테스트 용이성을 확보.
- 단/다중 뽑기 모두에서 **중복 방지 로직(ownedKeys)** 을 주입 → 체감 품질 개선.
- `canRecruit` 플래그로 **중복 입력/연타 방지**를 단순하면서 확실하게 처리
</details>
<details>
<summary><h4>2. 광산 FSM</h4></summary>

*담당자 : 이수명*

- 경량 FSM + 애니메이터 직결: Idle/Walk/Work를 간단한 enum FSM으로 관리하면서 Animator 스테이트를 직접 플레이
- 타일맵 장애물 탐지: IsObstacleBetween에서 타일맵을 따라 표본 샘플링으로 충돌을 판정. NavMesh 없이도 경량 경로 안전성을 확보
- 버프/쿨다운 HUD 내장: FSM 루프 안에서 버프 타이머와 쿨다운 텍스트를 관리하여, 작업 애니메이션 사이클과 시각 정보를 동일 생명주기로 묶어둔 설계

### 예시 코드

```csharp
enum State { Idle, Walk, Work }
------------------------------------
private void SetState(State newState)
{
    state = newState;
    wanderTimer = 0;
    if (anim == null) return;

    switch (state)
    {
        case State.Idle:
            anim.Play("Idle");
            wanderInterval = UnityEngine.Random.Range(0.7f, 1.2f);
            break;
        case State.Walk:
            anim.Play("Block");
            SoundManager.Instance?.Play("MineWalkSound");
            break;
        case State.Work:
            workAnimMax = UnityEngine.Random.Range(3, 11);
            workAnimCount = 0;
            anim.Play("Slash");
            SoundManager.Instance?.Play("MineSound");
            break;
    }
}
------------------------------------
private void HandleBuffAndCooldown()
{
    // ؽƮ  
    if (isBuffActive)
    {
        buffTimer -= Time.deltaTime;
        if (buffTimer > 0)
        {
            UpdateCooldownText(buffTimer);
        }
        else
        {
            EndBuff();
        }
    }
}
-----------------------------------
private bool IsObstacleBetween(Vector2 from, Vector2 to)
{
    if (obstacleTilemaps == null || obstacleTilemaps.Count == 0) return false;

    int steps = 8;
    for (int i = 1; i <= steps; ++i)
    {
        Vector2 pos = Vector2.Lerp(from, to, i / (float)steps);
        foreach (var tmap in obstacleTilemaps)
        {
            Vector3Int cell = tmap.WorldToCell(pos);
            if (tmap.HasTile(cell))
                return true;
        }
    }
    if (Physics2D.OverlapCircle(to, 0.3f, LayerMask.GetMask("Obstacle")))
        return true;

    return false;
}
```

- FSM 전환 시 **애니메이터 트리거 없이 직접 anim.Play**로 간소화 → 상태·연출 등 라이트한 결합
- 장애물 판정은 연속 보간 표본화(8스텝)로 계산량을 제한하면서도 실전 충분 수준의 충돌 감지
- 버프 HUD를 FSM 루틴 안에서 갱신 → 작업 주기와 UI가 자연 동기화
</details>
<details>
<summary><h4>3. 다중 해상도 지원 튜토리얼 하이라이트</h4></summary>

*담당자 : 박경택*

- 좌표 정규화 방식: 클릭/지시 위치를 화면 비율(xRatio, yRatio)로 저장·활용 → 기기 해상도/비율이 달라도 정확히 같은 지점 표시.
- 타자 효 코루틴: 직관적이면서 인터럽트 가능한 텍스트 출력. 튜토리얼 몰입감 상승.

### 예시 코드

```csharp
private IEnumerator TypeText(string text)
{
    isTyping = true;
    tutorialText.text = "";
    foreach (char c in text)
    {
        tutorialText.text += c;
        yield return WaitForSecondsCache.Wait(0.03f); // 속도 조절 가능
    }
    isTyping = false;
}
------------------------------------
public void HighlightPos(float xRatio, float yRatio)
{
    Vector2 normalized = new Vector2(xRatio, yRatio);

    effect.ShowHighlight(normalized);
    Vector2 screenPos = new Vector2(xRatio * Screen.width, yRatio * Screen.height);

    Canvas canvas = arrowIcon.GetComponentInParent<Canvas>();
    if (canvas == null)
    {
        return;
    }

    RectTransform canvasRect = canvas.GetComponent<RectTransform>();
    RectTransformUtility.ScreenPointToLocalPointInRectangle(canvasRect, screenPos, uiCam, out Vector2 localPos);

    arrowIcon.GetComponent<RectTransform>().anchoredPosition = localPos + new Vector2(20f, 0f);
}
```

- 정규화 좌표 → `LocalPointInRectangle` 변환으로 **UI 스케일/캔버스 해상도 차**를 깨끗하게 흡수.
- `WaitForSecondsCache`를 통한 **GC 최소화 패턴**까지 적용
</details>
<details>
<summary><h4>4. Additive 씬 로더 & 카메라/페이드/음향 일원화</h4></summary>

*담당자 : 장민제*

- LoadSceneMode.Additive로 씬을 겹쳐 올리고, 끝에 SetActiveScene으로 포커스를 넘김. “씬 덮어쓰기”가 아닌 “레이어 쌓기” 방식이라 UI·카메라 관리가 훨씬 유연함
- 로딩 캔버스 알파/블록레이 + AnimationCurve 기반 페이드 + BGM 전환을 한 매니저에서 일관 관리
- Mine/Forge 카메라 상태 플래그(SceneCameraState) 로 메인 카메라 활성/비활성 레이스컨디션을 막는 보강 루틴까지 포함

### 예시 코드

```csharp
public void LoadSceneAsync(SceneType type, bool isAdditive = false)
{
    loadingAnim.SetBool(loadingHash, true);

    string bgmName = GetBGMNameBySceneType(type);
    SoundManager.Instance?.StopBGM();
    SoundManager.Instance?.Play(bgmName);

    _lastActiveSceneType = type;

    StartCoroutine(LoadSceneCoroutine(SceneName.GetSceneByType(type), isAdditive));
}
------------------------------------
IEnumerator LoadSceneCoroutine(string sceneName, bool isAdditive)
{
    loadingCanvas.blocksRaycasts = true;
    loadingCanvas.alpha = 1f;

    AsyncOperation asyncOperation = SceneManager.LoadSceneAs...me, isAdditive ? LoadSceneMode.Additive : LoadSceneMode.Single);
    yield return new WaitUntil(() => asyncOperation.isDone);

    if (isAdditive)
    {
        Scene loadedScene = SceneManager.GetSceneByName(sceneName);
        if (loadedScene.IsValid())
            SceneManager.SetActiveScene(loadedScene);
    }

    EnsureMainCameraActive();
    yield return StartCoroutine(FadeRoutine(fadeInCurve, false));
}
----------------------------------
private IEnumerator UnLoadSceneCoroutine(string sceneName, SceneType remainSceneType)
{
    loadingCanvas.blocksRaycasts = true;
    loadingCanvas.alpha = 1f;
    loadingAnim.SetBool(loadingHash, true);

    AsyncOperation asyncOperation = SceneManager.UnloadSceneAsync(sceneName);
    yield return new WaitUntil(() => asyncOperation.isDone);
    ...
    string remainBgmName = GetBGMNameBySceneType(remainType);
    SoundManager.Instance?.StopBGM();
    SoundManager.Instance?.Play(remainBgmName);

    _lastActiveSceneType = remainType;
}
------------------------------
private IEnumerator FadeRoutine(AnimationCurve curve, bool blockRaycasts)
{
    float time = 0f;
    loadingCanvas.blocksRaycasts = blockRaycasts;

    while (time < fadeDuration)
    {
        float t = time / fadeDuration;
        loadingCanvas.alpha = curve.Evaluate(t);
        time += Time.deltaTime;
        yield return null;
    }

    loadingCanvas.alpha = 0f; // Fade 끝난 후 로딩창 숨김
    loadingCanvas.blocksRaycasts = false;
    loadingAnim.SetBool(loadingHash, false);
}

------------------------------
private void EnsureMainCameraActive()
{
    if (!SceneCameraState.IsMineSceneActive)
    {
        if (mainCameraObject != null && !mainCameraObject.activeSelf)
        {
            mainCameraObject.SetActive(true);
            var cam = mainCameraObject.GetComponent<Camera>();
            if (cam != null && !cam.enabled)
                cam.enabled = true;
        ...
-----------------------------------------
```
</details>
<details>
<summary><h4>5. Addressables로 제자 프리팹 로드 + FSM 동기화</h4></summary>

*담당자 : 이수명*

- Addressables 키로 제자 프리팹을 비동기로 로드 → 스폰 직후 FSM 초기화/버프상태를 즉시 동기화합니다.
- 슬롯 UI ↔ FSM 인스턴스 매핑을 관리하여, 교체/제거 시 등록/해제 누수를 방지합니다.

### 예시 코드

```csharp
void SpawnAssistantInMine(int mineIdx, MineAssistantSlotUI slotUI, AssistantInstance assistant,
bool isBuffActive, float buffRemain, bool isCooldown, float cooldownRemain)
{
    if (mineIdx < 0 || mineIdx >= mineGroups.Count) return;
    var group = mineGroups[mineIdx];

    Transform spawnPoint = group.spawnPoint;
    Transform assistantsRoot = group.assistantsRoot;
    if (spawnPoint == null || assistantsRoot == null)
        return;

    string key = $"Assets/Prefabs/Assistant/{assistant.Key}.prefab";
    Addressables.LoadAssetAsync<GameObject>(key).Completed += handle =>
    {
        if (handle.Status != AsyncOperationStatus.Succeeded || handle.Result == null)
            return;

        Vector3 spawnPos = spawnPoint.position;
        spawnPos.z = -1;
        GameObject go = Instantiate(handle.Result, spawnPos, Quaternion.identity, assistantsRoot);

        var sr = go.GetComponent<SpriteRenderer>();
        if (sr != null)
            sr.sortingOrder = 104;

        var fsm = go.GetComponent<MineAssistantFSM>();
        if (fsm != null)
        {
            fsm.Init(assistant, mineIdx, assistantsRoot.gameObject, this);

            // FSM 상태 동기화!
            fsm.LoadBuffState(isBuffActive, buffRemain, isCooldown, cooldownRemain);

            // --- FSM 등록 ---
            var slotObjRef = slotUI.gameObject.GetComponent<MineAssistantSlotUIObjectRef>();
            if (slotObjRef != null && slotObjRef.spawnedObject != null)
                slotFsmDict.Remove(group.slots[group.slotUIs.IndexOf(slotUI)]);
...
        };
}

```

- 정규화 좌표 → `LocalPointInRectangle` 변환으로 **UI 스케일/캔버스 해상도 차**를 깨끗하게 흡수.
- `WaitForSecondsCache`를 통한 **GC 최소화 패턴**까지 적용
</details>
</details>

---

# 팀원 구성 및 연락처
| 이름 | 전화번호 | 이메일 | 깃허브 |
| :--- | :--- | :--- | :--- |
| 이수명 | 010-2001-1426 | soo199617@gmail.com | https://github.com/leesoomang |
| 박경택 | 010-4562-8542 | rudxorrmrwkd@gmail.com | https://github.com/PKingTeak |
| 장민제 | 010-4782-1657 | jmj1657@gmail.com | https://github.com/Jangminez |
| 이희민 | 010-3953-2909 | gmlals2909@gmail.com | PostMail-hub |
